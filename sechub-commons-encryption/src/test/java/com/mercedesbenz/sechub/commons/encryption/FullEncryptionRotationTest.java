// SPDX-License-Identifier: MIT
package com.mercedesbenz.sechub.commons.encryption;

import static org.assertj.core.api.Assertions.*;
import static org.junit.jupiter.api.Assertions.*;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.util.stream.Stream;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.ArgumentsProvider;
import org.junit.jupiter.params.provider.ArgumentsSource;

/**
 * This class tests not only the rotator, but also other parts of the encryption
 * library. It uses real ciphers which are generated by the cipher factory etc.
 * etc.
 *
 * So it is not a normal unit tests for the rotator but more an integration test
 * of the encryption library!
 *
 * @author Albert Tregnaghi
 *
 */
class FullEncryptionRotationTest {

    private static PersistentCipher cipher1Aes256;
    private static PersistentCipher cipher2Aes256;
    private static PersistentCipher cipher3Aes128;
    private static PersistentCipher cipher4Aes128;
    private static PersistentCipher cipher5None;
    private static PersistentCipher cipher6None;
    private static InitializationVector initialVector1aes256;
    private static InitializationVector initialVector2aes256;
    private static InitializationVector initialVector3None;
    private static InitializationVector initialVector3aes128;
    private EncryptionRotator rotatorToTest;

    @BeforeAll
    static void beforeAll() {
        PersistentCipherFactory factory = new PersistentCipherFactory();
        cipher1Aes256 = factory.createCipher(new DefaultSecretKeyProvider("x".repeat(32)), PersistentCipherType.AES_GCM_SIV_256);
        cipher2Aes256 = factory.createCipher(new DefaultSecretKeyProvider("y".repeat(32)), PersistentCipherType.AES_GCM_SIV_256);

        cipher3Aes128 = factory.createCipher(new DefaultSecretKeyProvider("x".repeat(16)), PersistentCipherType.AES_GCM_SIV_128);
        cipher4Aes128 = factory.createCipher(new DefaultSecretKeyProvider("y".repeat(16)), PersistentCipherType.AES_GCM_SIV_128);

        cipher5None = factory.createCipher(null, PersistentCipherType.NONE);
        cipher6None = factory.createCipher(null, PersistentCipherType.NONE);

        initialVector1aes256 = cipher1Aes256.createNewInitializationVector();
        initialVector2aes256 = cipher2Aes256.createNewInitializationVector();
        initialVector3aes128 = cipher2Aes256.createNewInitializationVector();
        initialVector3None = cipher5None.createNewInitializationVector();

    }

    @BeforeEach
    void beforeEach() {
        rotatorToTest = new EncryptionRotator();
    }

    @Test
    void secret_rotation_cipher_none()
            throws InvalidKeyException, IllegalArgumentException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        /* prepare */
        byte[] rawPlainTextBytes = "hello".getBytes(EncryptionConstants.UTF8_CHARSET_ENCODING);

        NoneCipher noneCipher1 = new NoneCipher();
        InitializationVector vector1 = noneCipher1.createNewInitializationVector();
        NoneCipher noneCipher2 = new NoneCipher();

        /* @formatter:off */
        EncryptionRotationSetup setup = EncryptionRotationSetup.builder().
                oldCipher(noneCipher1).
                oldInitialVector(vector1).
                newCipher(noneCipher2).
                build();

        /* @formatter:on */

        /* execute */
        byte[] result = rotatorToTest.rotate(rawPlainTextBytes, setup);

        /* test */
        assertArrayEquals(rawPlainTextBytes, result);
    }

    @ParameterizedTest
    @ArgumentsSource(DualCipherSameInitVectorArgumentsProvider.class)
    void cipher_rotation_same_initial_vector(String testInfo, PersistentCipher cipher1, PersistentCipher cipher2, InitializationVector initVector) {
        /* prepare */
        String textToEncrypt = "Hello, I am ☺️ 4 you.";
        byte[] rawBytesToEncrypt = textToEncrypt.getBytes(EncryptionConstants.UTF8_CHARSET_ENCODING);

        byte[] encryptedWithCipher1 = cipher1.encrypt(rawBytesToEncrypt, initVector);

        /* execute */
        /* @formatter:off */
        EncryptionRotationSetup setup = EncryptionRotationSetup.builder().
                oldCipher(cipher1).
                oldInitialVector(initVector).
                newCipher(cipher2).
                build();

        /* @formatter:on */
        byte[] encryptedAfterRotation = rotatorToTest.rotate(encryptedWithCipher1, setup);

        // sanity check for this test: the encryption may not be same...
        assertThat(encryptedAfterRotation).isNotEqualTo(encryptedWithCipher1);

        /* test */
        byte[] decryptedWithCipher2AfterRotation = cipher2.decrypt(encryptedAfterRotation, initVector);

        assertThat(rawBytesToEncrypt).isEqualTo(decryptedWithCipher2AfterRotation);

    }

    @ParameterizedTest
    @ArgumentsSource(DualCipherDifferentInitVectorArgumentsProvider.class)
    void cipher_rotation_different_initial_vector_and_different_cipher(String testInfo, PersistentCipher cipher1, PersistentCipher cipher2,
            InitializationVector initVector1, InitializationVector initVector2) {
        /* prepare */
        String textToEncrypt = "Hello, I am ☺️ 4 you.";
        byte[] rawBytesToEncrypt = textToEncrypt.getBytes(EncryptionConstants.UTF8_CHARSET_ENCODING);

        byte[] encryptedWithCipher1 = cipher1.encrypt(rawBytesToEncrypt, initVector1);

        /* execute */
        /* @formatter:off */
        EncryptionRotationSetup setup = EncryptionRotationSetup.builder().
                oldCipher(cipher1).
                oldInitialVector(initVector1).
                newCipher(cipher2).
                newInitialVector(initVector2).
                build();

        /* @formatter:on */
        byte[] encryptedAfterRotation = rotatorToTest.rotate(encryptedWithCipher1, setup);

        // sanity check for this test: the encryption may not be same...
        assertThat(encryptedAfterRotation).isNotEqualTo(encryptedWithCipher1);

        /* test */
        byte[] decryptedWithCipher2AfterRotation = cipher2.decrypt(encryptedAfterRotation, initVector2);

        assertThat(rawBytesToEncrypt).isEqualTo(decryptedWithCipher2AfterRotation);

    }

    private static class DualCipherSameInitVectorArgumentsProvider implements ArgumentsProvider {
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) {
            /* @formatter:off */

            return Stream.of(
                    Arguments.of("cipher1(aes256)->2(aes256)", cipher1Aes256, cipher2Aes256, initialVector1aes256),
                    Arguments.of("cipher1(aes256)->3(aes128)", cipher1Aes256, cipher3Aes128, initialVector1aes256),
                    Arguments.of("cipher2(aes256)->1(aes256)", cipher2Aes256, cipher1Aes256, initialVector2aes256),
                    Arguments.of("cipher3(aes128)->1(aes256)", cipher3Aes128, cipher1Aes256, initialVector3aes128),
                    Arguments.of("cipher3(aes128)->4(aes128)", cipher3Aes128, cipher4Aes128, initialVector3aes128),
                    Arguments.of("cipher2(aes256)->5(none)", cipher2Aes256, cipher5None, initialVector1aes256),
                    Arguments.of("cipher5(none)->1(aes256)", cipher5None, cipher1Aes256, initialVector1aes256)

            );
            /* @formatter:on */
        }
    }

    private static class DualCipherDifferentInitVectorArgumentsProvider implements ArgumentsProvider {
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) {
            /* @formatter:off */

            return Stream.of(
                    Arguments.of("cipher1(aes256)->2 (aes256)", cipher1Aes256, cipher2Aes256, initialVector1aes256, initialVector2aes256),
                    Arguments.of("cipher5(none)->1 (aes256)", cipher5None, cipher2Aes256, initialVector3None, initialVector2aes256),
                    Arguments.of("cipher2(aes256)->5 (none)", cipher2Aes256, cipher5None, initialVector2aes256, initialVector3None),
                    Arguments.of("cipher6(none)->4(aes128)", cipher6None, cipher4Aes128, initialVector3None, initialVector2aes256)

                    );
            /* @formatter:on */
        }
    }

}
