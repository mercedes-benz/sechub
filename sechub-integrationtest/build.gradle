// SPDX-License-Identifier: MIT
 /*============================================================================
 * Build file for subproject
 *
 * Root build file: "${rootProject.projectDir}/build.gradle"
 * ============================================================================
 */
dependencies {

    compile project(':sechub-testframework')
    compile project(':sechub-adapter') // we reuse trustall approach from adapters
    compile project(':sechub-shared-kernel') // we want to have access to some shared kernel parts (e.g. trafficlight)
    compile library.springboot_starter_mail // to have easier access to email parts
}

/* defaults like set in `application-pds_integrationtest.yml` */
def integrationTestServerPortValue = 8443;
def integrationTestPDSPortValue = 8444;

def pdsVersion = VersionData.getPdsVersion()
def serverVersion = VersionData.getServerVersion()

task copyIntegrationTestResults(type: Copy) {
        with{
            from "${project.projectDir}/build/test-results/integrationtest"
            into "${combined_report_junit_tmp}"
            include "*.xml"
        }
}
task copyIntegrationServerLogs(type: Copy) {
        with{
            from "${project.projectDir}"
            into "${combined_report_target}"
            include "integrationtest-*.log"
        }
}
copyTestResults.dependsOn copyIntegrationTestResults
copyTestResults.dependsOn copyIntegrationServerLogs


task cleanLogFiles(type: Delete){
       delete "${project.projectDir}/integrationtest-*.log" 
}
tasks.clean.dependsOn(tasks.cleanLogFiles)

task configureIntegrationTestServer{
    def integrationTestServerPortProperty="sechub.integrationtest.serverport";
    if ( project.hasProperty(integrationTestServerPortProperty)){
        integrationTestServerPortValue = project.getProperty(integrationTestServerPortProperty)
    }
}
task configureIntegrationTestPDS{
    def integrationTestPDSPortProperty="sechub.integrationtest.pdsport";
    if ( project.hasProperty(integrationTestPDSPortProperty)){
        integrationTestPDSPortValue = project.getProperty(integrationTestPDSPortProperty)
    }
}

task waitForStop(dependsOn: [configureIntegrationTestServer, configureIntegrationTestPDS]){
    doLast{
        new IntegrationTestServerScriptAccess().waitForStop(new File("${project.projectDir}"),"$integrationTestServerPortValue")
        new IntegrationTestPDSScriptAccess().waitForStop(new File("${project.projectDir}"),"$integrationTestPDSPortValue")
    }

}

task stopOldIntegrationTestServer(dependsOn: configureIntegrationTestServer){
    doLast{
        new IntegrationTestServerScriptAccess().stop(new File("${project.projectDir}"),"$integrationTestServerPortValue")
    }

}

task stopOldIntegrationTestPDS(dependsOn: configureIntegrationTestPDS){
    doLast{
        new IntegrationTestPDSScriptAccess().stop(new File("${project.projectDir}"),"$integrationTestPDSPortValue")
    }

}

/** Starts integraitontestserver
 *  If another integration test server runs, the script will terminate the other server automatically - will kill zombies.
 */
task startIntegrationTestServer(dependsOn: stopOldIntegrationTestServer){
    group 'sechub'

    description 'Starts an integration test server - if already a server is running we will wait until timout (10 minutes). ' +
                'When timeout build fails but "zombie server" will be stopped too!'
    doLast{
        new IntegrationTestServerScriptAccess().start(new File("${project.projectDir}"), "$serverVersion","$integrationTestServerPortValue")
    }

}

/** Starts integraitontestserver
 *  If another integration test server runs, the script will terminate the other server automatically - will kill zombies.
 */
task startIntegrationTestPDS(dependsOn: stopOldIntegrationTestPDS){
    group 'sechub'

    description 'Starts an integration PDS server - if already a server is running we will wait until timout (10 minutes). ' +
                'When timeout build fails but "zombie server" will be stopped too!'
    doLast{
        new IntegrationTestPDSScriptAccess().start(new File("${project.projectDir}"), "$pdsVersion", "$integrationTestPDSPortValue")
    }

}

task startIntegrationTestInstances(dependsOn: [startIntegrationTestServer, startIntegrationTestPDS]){
}



task stopIntegrationTestServer(dependsOn: configureIntegrationTestServer){
    doLast{
        new IntegrationTestServerScriptAccess().stop(new File("${project.projectDir}"),"$integrationTestServerPortValue")
    }
}
task stopIntegrationTestPDS(dependsOn: configureIntegrationTestServer){
    doLast{
        new IntegrationTestPDSScriptAccess().stop(new File("${project.projectDir}"),"$integrationTestPDSPortValue")
    }
}

task stopIntegrationTestInstances(dependsOn: [stopIntegrationTestServer, stopIntegrationTestPDS]){
}


/**
 * Own task for integration tests.
 */
task integrationtest(type: Test, dependsOn: startIntegrationTestInstances) {
   group 'sechub'
   description 'Starts integration test server, execute tests and automatically stops server after done or failed'
   // integration tests seems to be very often  "up-to-date"
   // but we want them always to be executed, so next line...
   outputs.upToDateWhen { false }
   /*
    *  We must set the system property here - gradle does fork
    * the jvm on testing and does not add system properties of calling automatically so we set
    * integration test properties here
    */
   systemProperty "sechub.integrationtest.running", "true"
   systemProperty "sechub.integrationtest.longrunning", "true"

   finalizedBy "stopIntegrationTestInstances"

}



/**
 * Special groovy class for executing external script. This is because exec task of groovy does ALWAYS wait until process has executed.
 * Unfortunately this has blocked always when using exec in combination (server runs) - even when using "&" option.
 * So this class was created to use just the java process builder.
 */
class IntegrationTestScriptAccess extends CmdExecutor{
       private String scriptName;
       
       public IntegrationTestScriptAccess(String scriptName){
            this.scriptName=scriptName;
       }

       public void waitForStop(File workingDir, String port) throws Exception{
            executeScript("waitForStop",workingDir,null,-1,port)
       }

       public void stop(File workingDir,String port) throws Exception{
            executeScript("stop",workingDir,null,60,port)
       }

       public void start(File workingDir, String useVersion,String port) throws Exception{
            executeScript("start",workingDir,useVersion,300,port); /* max 5 minutes */
       }

       private void executeScript(String command, File workingDir, String useVersion, int timeOutInSeconds,String port) throws Exception{
          CmdExecutor exec = new CmdExecutor();
          exec.setTimeOutInSeconds(timeOutInSeconds);
          if (OSUtil.isWindows()){
             exec.getCommand().add("cmd");
             exec.getCommand().add("/c");
             exec.getCommand().add(scriptName+".bat");
          }else{
             exec.getCommand().add("./"+scriptName+".sh");
          }
          exec.getCommand().add(command);
          if (command.equals("start")){
             exec.getCommand().add("$useVersion");
          }
          exec.getCommand().add("$port");

          exec.execute(workingDir)
        }


}

class IntegrationTestServerScriptAccess extends IntegrationTestScriptAccess{
    public IntegrationTestServerScriptAccess(){
        super("integrationtest-server");
    }
}

class IntegrationTestPDSScriptAccess extends IntegrationTestScriptAccess{
    public IntegrationTestPDSScriptAccess(){
        super("integrationtest-pds");
    }
}

