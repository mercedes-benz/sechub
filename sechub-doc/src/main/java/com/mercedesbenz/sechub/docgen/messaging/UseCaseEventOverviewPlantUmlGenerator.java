// SPDX-License-Identifier: MIT
package com.mercedesbenz.sechub.docgen.messaging;

import static com.mercedesbenz.sechub.docgen.GeneratorConstants.*;

import java.io.File;
import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.TreeSet;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.mercedesbenz.sechub.docgen.util.DocGenTextFileReader;
import com.mercedesbenz.sechub.docgen.util.DocGenTextFileWriter;
import com.mercedesbenz.sechub.sharedkernel.messaging.IntegrationTestEventHistory;
import com.mercedesbenz.sechub.sharedkernel.messaging.IntegrationTestEventHistoryInspection;
import com.mercedesbenz.sechub.sharedkernel.usecases.UseCaseIdentifier;
import com.mercedesbenz.sechub.sharedkernel.util.FilenameVariantConverter;

/**
 * Generates overview plantuml parts - for JSON files generated by event trace
 * tests before.
 *
 * @author Albert Tregnaghi
 *
 */
public class UseCaseEventOverviewPlantUmlGenerator {

    public static final FilenameVariantConverter filenameVariantconverter = new FilenameVariantConverter();

    private static final Logger LOG = LoggerFactory.getLogger(UseCaseEventOverviewPlantUmlGenerator.class);
    private File folderToStartFrom;
    private DocGenTextFileReader reader;
    private DocGenTextFileWriter writer;
    private File outputFolder;
    private Map<UseCaseIdentifier, Set<String>> usecaseNameToMessageIdsMap = new TreeMap<>();

    public UseCaseEventOverviewPlantUmlGenerator(File jsonEventDataFolder, File outputFolder) {
        this.folderToStartFrom = jsonEventDataFolder;
        this.outputFolder = outputFolder;
        this.reader = new DocGenTextFileReader();
        this.writer = new DocGenTextFileWriter();
    }

    /**
     * After generation this will return a filled map containing information about
     * which usecase has a relation to which messages. Can be used for further
     * generation
     *
     * @return filled map
     */
    public Map<UseCaseIdentifier, Set<String>> getUsecaseNameToMessageIdsMap() {
        return usecaseNameToMessageIdsMap;
    }

    public void generateAndRememberUsecaseNamesToMessageIdMapping() {
        LOG.info("start collecting event trace data from:" + folderToStartFrom.getAbsolutePath());

        File[] files = folderToStartFrom.listFiles();
        if (files == null || files.length == 0) {
            /*
             * health check - we fail when no event trace information available. Reason:
             * Otherwise somebody could generate a documentation where no overviews would be
             * contained!
             */
            throw new IllegalStateException("Health check failure!!! Event trace data missing!\n\n"
                    + "Explanation: Event trace data is missing. Seems you have not run integration tests before. These tests generate the missing data, which can only be done at server runtime.\n"
                    + "So please execute integration tests (e.g. by doing a `./gradlew integrationtest`) and restart documentation generation\n");
        }
        for (File folder : files) {
            generateFolder(folder);
        }

    }

    private void generateFolder(File folder) {
        if (!folder.isDirectory()) {
            if (DEBUG) {
                LOG.info("not a folder:{}", folder);
            }
            return;
        }
        for (File file : folder.listFiles()) {
            generateFile(file);
        }
    }

    private void generateFile(File jsonSourceFile) {
        String fileName = jsonSourceFile.getName();
        if (!fileName.endsWith(".json")) {
            if (DEBUG) {
                LOG.info("ignoring filename:{}", fileName);
            }
            return;
        } else {
            if (DEBUG) {
                LOG.info("inspect filename:{}", fileName);
            }
        }
        String variant = filenameVariantconverter.getVariantFromFilename(fileName);
        String originFileName = filenameVariantconverter.getFilenameWithoutVariant(fileName);
        String usecaseId = originFileName.substring(0, originFileName.length() - 5); /* .json = 5 chars */
        UseCaseIdentifier usecaseIdentifier;
        try {
            usecaseIdentifier = UseCaseIdentifier.valueOf(usecaseId.toUpperCase());
        } catch (RuntimeException e) {
            LOG.error("File not a usecase:" + jsonSourceFile);
            return;
        }
        LOG.info("Generate for usecase:{}, using json file: {}", usecaseIdentifier.name(), jsonSourceFile.getAbsolutePath());
        if (jsonSourceFile.getAbsolutePath().endsWith("uc_admin_enables_scheduler_job_processing.json")) {
            System.out.println("got");
        }
        String json = reader.readTextFromFile(jsonSourceFile);
        IntegrationTestEventHistory history = IntegrationTestEventHistory.fromJSONString(json);
        try {
            generate(history, usecaseIdentifier, variant);
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException("Wrong class names? Maybe you need to retrigger Integration tests to get new JSON files!", e);
        } catch (IOException e) {
            throw new IllegalStateException("Was not able to write file!", e);
        }

    }

    private void generate(IntegrationTestEventHistory history, UseCaseIdentifier usecaseIdentifier, String variant) throws ClassNotFoundException, IOException {
        Set<String> messages = ensuredMessages(usecaseIdentifier);

        SortedMap<Integer, IntegrationTestEventHistoryInspection> map = history.getIdToInspectionMap();
        Set<Integer> keySet = map.keySet();

        PumlBuilder pb = new PumlBuilder();
        pb.add("@startuml");
        pb.add("skinparam style strictuml");
        /* define actors etc. */
        pb.add("actor " + usecaseIdentifier.name());

        /* build domain list */
        Set<String> domains = new TreeSet<>();
        /* define actors etc. */
        for (Integer inspectionId : keySet) {
            IntegrationTestEventHistoryInspection inspection = map.get(inspectionId);
            messages.add(inspection.getEventId());

            Class<?> sender = Class.forName(inspection.getSenderClassName());
            domains.add(DomainUtil.createDomainName(sender));

            for (String receiverClass : inspection.getReceiverClassNames()) {
                Class<?> receiver = Class.forName(receiverClass);
                domains.add(DomainUtil.createDomainName(receiver));
            }
        }
        /* generate domain list as collections in puml */
        for (String domain : domains) {
            pb.add("collections " + domain);
        }

        /* link them */
        for (Integer identifier : keySet) {
            pb.add("== " + identifier.toString() + " ==");
            IntegrationTestEventHistoryInspection inspection = map.get(identifier);
            Class<?> sender = Class.forName(inspection.getSenderClassName());
            String senderDomain = DomainUtil.createDomainName(sender);
            if (identifier.intValue() == 0) {
                /* first one , so show usecase starts */
                pb.add(usecaseIdentifier.name() + " -> " + senderDomain + ": executed");
            }
            if (inspection.isSynchron()) {

                for (String receiverClass : inspection.getReceiverClassNames()) {
                    Class<?> receiver = Class.forName(receiverClass);
                    String receiverDomain = DomainUtil.createDomainName(receiver);
                    pb.add(senderDomain + " -> " + receiverDomain + " : " + inspection.getEventId());
                }

            } else {

                for (String receiverClass : inspection.getReceiverClassNames()) {
                    Class<?> receiver = Class.forName(receiverClass);
                    String receiverDomain = DomainUtil.createDomainName(receiver);
                    pb.add(senderDomain + " ->> " + receiverDomain + " : " + inspection.getEventId());
                }
            }

        }
        pb.add("@enduml");

        /* write PLANTUML file */
        File targetFile = new File(outputFolder, createPlantumlFileSubPathByUsecase(usecaseIdentifier.name(), variant));
        writer.writeTextToFile(targetFile, pb.getPlantUML());

    }

    private Set<String> ensuredMessages(UseCaseIdentifier usecaseIdentifier) {
        Set<String> messages = usecaseNameToMessageIdsMap.get(usecaseIdentifier);
        if (messages == null) {
            messages = new TreeSet<>();
            usecaseNameToMessageIdsMap.put(usecaseIdentifier, messages);
        }
        return messages;
    }

    public static String createPlantumlFileSubPathByUsecase(String usecaseIdentifierEnumName, String variant) {
        String fileName = "/event_overview_" + createUsecaseId(usecaseIdentifierEnumName) + ".puml";
        fileName = filenameVariantconverter.toVariantFileName(fileName, variant);
        return createPlantumlFolderSubPathByUsecase(usecaseIdentifierEnumName) + "/" + fileName;
    }

    public static String createPlantumlFolderSubPathByUsecase(String usecaseIdentifierEnumName) {
        return "usecase-event-overview/" + createUsecaseId(usecaseIdentifierEnumName);
    }

    public static String createUsecaseId(String usecaseIdentifierEnumName) {
        String lowerCase = usecaseIdentifierEnumName.toLowerCase();
        return lowerCase;
    }

    public static String createUsecaseId(UseCaseIdentifier identifier) {
        return createUsecaseId(identifier.name());
    }

    private class PumlBuilder {
        StringBuilder sb = new StringBuilder();

        public void add(String line) {
            sb.append(line);
            sb.append("\n");
        }

        public String getPlantUML() {
            return sb.toString();
        }
    }

}
