// SPDX-License-Identifier: MIT
[[section-shared-concepts-data-encryption]]
In SecHub we have some sensitive data we want to be encrypted. For example: Inside remote data
section the configuration contains credentials to fetch data. These sensitive information shall not
be available unencrypted.

==== General
We want 

. Data consistency +
- It shall not be possible that we loose data by encryption in any way. +
  It must be ensured that the servers are always able to read and write data.

. Full automated cipher rotation +
There is no need for manual interaction - means it is not necessary to create any cron jobs or
something else to convert non encrypted data to encrypted data or to rotate a password or to
use a new encryption method.

. Data protection /Privacy policy
- Even for administrators it shall not be possible to fetch the information directly +
  _(of course a person who knows the encryption password and has access to the database will always
   be able to calculate values - but we separate here between administration and operation inside
   this concept, so protection is fully possible)_
- The data must not be accidentally made available in decrypted form - for example through a REST 
  call in which the data object is passed along unencrypted.
  
. Easy encryption administration
  - It shall be possible for an administrator to configure a new cipher entry via REST 

. Secure storage of encryption passwords +
  - Encryption passwords are always provided via environment entries, we store always 
    the environment variable name to use inside the database but never plain values!

==== Cipher pool
We store the cipher information in a pool table in database: `SCHEDULE_CIPHER_POOL_DATA`.

[NOTE]
====
Why in schedule domain and only there? Because it is the responsible domain for the storage. All other
domains should NOT persist this information!
====

Here an an overview of the table (names can be different in database):

[options="header"]
|===                                                                         
|id   |algorithm      | password_source_type  |password_source_data| encoding |test_text       | test_initial_vector| test_encrypted     | creation_timestamp   |created_from                      
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
|0    |NO_ENCRYPTION  | PLAIN_TEXT            |                    | PLAIN    |no-encryption   |                    | no-encryption      | 2024-06-24_10:00:01  | null 
|1    |AES_GSCM_SIV   | ENVIRONMENT_VARIABLE  |SECHUB_CRYPTO_P0    | PLAIN    |SecHub          | easdfa313334       | 53d$125666eeffeded | 2024-06-24_10:05:34  | Admin1
|2    |AES_GSCM_SIV   | ENVIRONMENT_VARIABLE  |SECHUB_CRYPTO_P1    | PLAIN    |Apfel           | fxadsfeec33s       | 13x313412124$rfewd | 2024-06-24_11:02:14  | Admin2
|===                                                                                                                                           

*algorithm*

Algorithm to use in encryption - currently we provide:

- NONE (only for SQL migration)
- AES_GSCM_SIV

*password_source_type*

Currently supported password source types are

. env +
  Here we provide environment variables, the password source data is the name of the environment variable

We separated source type and source data to be able to provide additional source - e.g. a password fault for the future.
                                                                             
*password_source_data*

Depends on the source

- If source is `env` than this is the name of the environment variable which holds the secret

====== Usage inside rows

Inside the encrypted rows we will persist the *pool id* together with an *initial vector*

*initial vector*
Some algorithm like `AES_GSCM_SIV` do need an initial vector to encrypt secure. The value here is
auto generated by SecHub and is dependent on the algorithm. Because in most cases it shall be random,
SecHub will auto generate a value when it comes to encryption.

The vector will be stored together with the encrypted data. 

[NOTE]
====
Maybe it becomes necessary to provide a additional column in future when a new source type is
implemented - e.g a password fault. Maybe a `valid_until` becomes necessary and automatical refresh and more.
But to keep things simple we currently do not provide this.  
====
                                                                        
====== Administration of cipher pool
*Usecase: Admin adds new cipher pool entry*

An administrator is able to add a new entry into the cipher pool table via REST API (but there
is no REST call available to remove an entry, this will be done automatically by SecHub when 
it becomes possible)

----
/api/admin/cipher/add
----

Example json body:
[source,json]
----
{
    "algorithm" : "AES_GSCM_SIV", <1>
    "passwordSourceType" : "environment-variable",<2>
    "passwordSourceData" : "SECHUB_CRYPTO_P1",<3>
    "testText" : "Apfel"<4>
   
}
----
<1> algorithm (possible values are `AES_GSCM_SIV`, `NO_ENCRYPTION` is a algorith definition, but is not accepted by REST api, because designed only for SQL migration)
<2> password source type, supported is currently only `environment-variable`.
<3> the source for the password. For environment variables this must be the name of the variable which is given to Server on server startup
<4> The test text. This value will be encrypted on server side with the given cipher type (e.g. `AES_GSCM_SIV`)
    on server side when creating the new pool entry, this text will be stored encrypted inside `test_encrypted`
    column (used at server startup to ensure variables are correct set and it is possible to encrypt data)

*Usecase: Admin lists all current cipher pool entries*

----
/api/admin/cipher/list
----

Example result:

[source,json]
----
{
   {
        "id": "0",
        "algorithm" : "NONE",
        "envVar" : null,
        "testText" : null,
        "created" : "2024-06-24_10:00:01",
        "initialVector" : "gen-uuid1"
   },
   {
        "id": "1",
        "algorithm" : "AES_GSCM_SIV",
        "envVar" : "SECHUB_CRYPTO_P0",
        "testText" : "SecHub1",
        "testEncrypted" : "53d$125666eeffeded",
        "created" : "2024-06-24_10:05:34",
        "initialVector" : "gen-uuid2"
   },
   {
        "id": "2",
        "algorithm" : "AES_GSCM_SIV",
        "envVar" : "SECHUB_CRYPTO_P1",
        "testText" : "13x313412124$rfewd",
        "created" : "2024-06-24_11:02:14",
        "initialVector" : "gen-uuid3"
   }
}
----

===== Server startup blocking

A SecHub server will stop on startup phase when

- one of the entries inside the cipher pool cannot be handled by this server.  +
This ensures that every new started server is able to handle all of them / is always readable.

===== Auto cleanup inside Cipher pool
For the <<concept-auto-cleanup,auto cleanup>> mechanism the use case with id: `UC_SCHEDULE_AUTO_CLEANUP_EXECUTION`
is extended to cleanup not only old jobs, but also to cleanup cipher pool entries which are no longer used
by any job - except the newest one which must be kept always.

When the entry is deleted, a log entry at info level is created containing the complete information about the
deleted log entry is done.

==== Scheduler jobs and encryption
===== Create new job
When a new job is created by scheduler, the scheduler will store the new job with latest supported cipher pool id
and use the necessary encryption here.
 
- `SCHEDULE_SECHUB_JOB` has a column `cipher_pool_id` to store this

==== Automatic job encryption updates
===== Canceled or ended jobs get auto encryption update
The `SchedulerJobEncryptionUpdateTriggerService` is fetches periodically (on every SecHub server cluster member)
all jobs jobs which are in execution state `ENDED` (means failed or success) or `CANCELED` which have not the 
latest cipher from pool and will do an encryption conversion here.

// FIXME 2024-06-27, de-jcup: maybe column "update_running" : boolean necessary -> upate -> softlock version..
Remark: maybe

One exception: If the current running server does NOT support the latest cipher from pool (means this server
instance has not the possibility to encrypt the data) the automation will only log a warning about encryption update
is not possible on this instance and do nothing!  

===== New / non approved jobs are handled by auto cleanup
Because there is the possibility that there are jobs which are created, but never approved, those jobs must be
handled as well. But we must ensure that we have no race conditions here (e.g. the job is now approved and job starts
running while the encryption data is changed).

To keep this as simple as possible and to ensure we have no race conditions, we just do not handle them directly,
but let this be done by the <<concept-auto-cleanup,auto cleanup>> mechanism, which will delete older jobs after a 
period of time automatically (see `ScheduleAutoCleanupService` for details).

==== Handling server update/migration
Old server versions do not have the encryption field inside the scheduler job table or the cipher pool table.

Our SQL migration scripts will initialize the cipher pool with a NONE entry (and id 0) and add the information
to all existing jobs.

==== Secure per default
When a {sechub} server starts and the cipher pool table does not contain an entry which is not a `NONE` 
type, a new entry is added automatically with `AES_GSCM_SIV` and the environment entry 
`SECHUB_CRYPTO_P0`. It is also checked in this case that the environment variable is not empty
- otherwise server will not start.

[NOTE]
====
`SECHUB_CRYPTO_P0` is special treated for integration tests! Here the spring value `sechub.crypto.p0` is possible
as well. This will be handled by registration process at serve startup where the supported parts
from cipher pool are determined.
====


==== Handling sensitive data at runtime
JVM crash dumps contain string information. To handle this risk the SecHubConfiguration model does 
contain sensitive data like remote data credentials and webScan login information always as sealed 
objects. The data is converted to plain text only when needed. 

When we have PDS data transfer we use directly json, means the sealed object is automatically unsealed.
Usage of direct json data shoud be reduced as much as as possible to avoid dump scenario.

[IMPORTANT]
====
As long as DDD is running inside one JVM using sealed objects is no problem at all at SecHub side, 
because it can be unsealed everywhere inside the JVM. But if we change our 
<<section-concepts-domain-driven-design,simple DDD approach>> and seperate {sechub} domain parts 
standalone, there will be a need to handle this similar to PDS communication (means json) because different JVMs 
would be used as well. 
====



===== Special usecas
====== For administrators and support
Because it can happen that an administrator is asked by a user to help with configuration problems,
it shall be possible to fetch a scheduler sechub configuration by administrators as plain text (json).

// TODO 2024-06-27, de-jcup: maybe asterisk handling like done for secret-scan secret results (configurable)  
But the sealed objects inside this configuration object shall be replaced with string data which contains only
asterisks. 

This is audit logged, means it is clear which person has accessed the configuration file.

====== Treatment of meta data inside SecHubConfiguration
SecHubConfiguration model is encrypted, because it can contain sensitive data. E.g. inside remote data
section.

There exists a REST endpoint which gives users the possiblity to fetch job information, together with
the meta data defined inside the {sechub} configuration. To obtain this information, the configuration
will be encrypted at runtime and the meta data are resolved. Because meta data shall not contain any
sensitive information, this will not be audit logged. 

===== Important infos about migration

====== Server 1.10.0 to 2.0.0

- Normally we a have zero downtime and rolling updates with k8s and SecHub. But here we need one!
  Reason: We must ensure there is no old server running which creates new jobs with
  unencrypted config part inside. To prevent such a situation (if somebody doest still a rolling update,
  we have changed the column name inside `schedule_sechub_job` from configuration to `unencrypted_configuration`.
  Old servers will no longer be able to write this and a SQL error will happen.
  - 
- K8s deployment

