// SPDX-License-Identifier: MIT
[[section-systemtests]]

== System tests
This chapter describes the system test framework.

=== We have integration test framework, why another one?
Integration tests do rely on that {sechub} is running in integration test mode, using one {pds}
server in integration test mode as well. 

In this scenario, the integration test API can fetch internal meta data and is able to check 
correctness of the logic inside {sechub} and also inside {pds}. But it does not test real product 
execution - at the end it uses only mocked test scripts and dedicated test data.    

The system tests are different to integration tests: The main purpose is to test 
{sechub} server(s) in combination with one or multiple {pds} solutions in real live scenarios.
This helps developers of {pds} solutions to drastically reduce development time and also to write 
automated tests without having to constantly test manually - a command line call in the OS shell or 
calling a unit test is sufficient. 

[TIP]
====
The system test framework is designed, to make things easier for developers
when testing {sechub} / {pds}. It provides as many defaults as possible.
So it is normally not necessary to define much to have a running system test!

Do not try to configure every possible part, but instead try to define only 
necessary things and let the framework do the rest.
====

=== Write a test
This chapter describes the different parts inside the test configuration model.

System tests can be written in two ways:

1. Write a JUnit test and use methods provided by `SystemTestAPI` or
2. Write a JSON file and execute it with `pds-tools`.

It does not matter if you write the configuration directly in JSON or with the java test API - 
the underlying model is the same. 


==== Variables

===== Environment variables
You can use environment variables inside the test configuration.
The prefix for those variables is `env`. 

For example, when you want to use the environment variable `USER_NAME` inside the 
configuration you reference it by `${env.USER_NAME}`.

[WARNING]
====
It is forbidden to use environment variables which have `${env.*` as content!
====

===== Secret environment variables
When an error appears, the altered configuration model will be logged as JSON to make it
easier to understand the problem. 

But inside this output, all standard variables (environment, runtime, user variables) are 
revealed and will be shown in plain text.

If you have any secret information which shall not be revealed inside log output this is no option
from a security perspective.

To hide such sensitive information you can use secret environment variables.

[WARNING]
====
It is forbidden to use secret environment variables which have `${env.*` or `${secretEnv.*` as content!
====
The prefix for those variables is `secretEnv`. 

For example, when you want to use the environment variable `USER_PASSWORD` inside the 
configuration you reference it by `${secretEnv.USER_PASSWORD}`.

[IMPORTANT]
====
When you are using secret environment variables but they are not defined at runtime,
the system test framework will fail with an error about the missing variables.
====

But those variables can only be used at some locations:

====== Inside script environments 
[source,json]
----
"script" : {
            "envVariables" : {
              "D_RESOLVED_SECRET" : "${secretEnv.USER_PASSWORD}" //<1>
            },
            "path" : "./05-start-single-sechub-network-docker-compose.sh",
            "arguments" : [ "will-not-be-revealed-as-argument:${secretEnv.USER_PASSWORD}" ] //<2>
          }
----
<1> This works, at runtime the environment entry for the script will contain `USER_PASSWORD` inside 
    variable `D_RESOLVED_SECRET`.
<2> The secret will not be sent as an argument (for security reasons we only allowe env entries)

====== Inside credentials
// FIXME 2023-04-05, albert: not implemented
TBD: Not implemented at the moment

===== User variables
You can define your own variables inside the test configuration.
The prefix for those variables is `variables`. 

For example, if you have defined the variable `uploadFolder` inside the 
configuration you can reference it by `${variables.uploadFolder}`.

===== Runtime variables
Some variables are created by the test framework and are available at runtime.
You can use such variables inside the test configuration with the prefix `runtime`.

include::../../gen/gen_systemtests_runtime_variables_table.adoc[]

====== Workspace root
On startup a temporary workspace folder will be created and can be used inside the configuration.
The variable can be referenced with `${runtime.workspaceRoot}`.

*An example:*

- write a bash script which downloads some test source code from a git repository.
- the bash script uses `$1` to determine the target folder
- inside our test configuration we set the first argument of a test prepare script to 
  `${runtime.workspaceRoot}/sources1`.
- inside the test itself we reference it again with `${runtime.workspaceRoot}/sources1`
  as working directory for the client upload.

==== Default fallbacks
[[section-systemtests-default-fallbacks]]
Following parts will be automatically defined in preparation phase when not defined explicit inside system test configuration model:

include::../../gen/gen_systemtests_default_fallbacks_table.adoc[]

==== Setup
Inside the setup we define things necessary to setup our system test environment.

It is possible to run system tests on local side and just automatically start SecHub, 
PDS solutions and configure all automatically.

But it is also possible to use an existing real {sechub} platform and run the defined
tests there. The configuration is not tampered here - executor configurations, users, projects
and profiles must be configured here. Also the usage of <<section-systemtests-local-defaults,local defaults>>   is not possible - except those parts are defined on remote site with such names!  


===== Local
When we run system tests on a local environment, all necessary data and setup will be done by the framework.
This means an administrator account is necessary to setup the system.

If not defined, the default credentials for integration test server will be used. If you not define
{sechub} or {pds}

===== Remote
It is also possible to use an existing real {sechub} platform and run the defined
tests there. The configuration is not tampered here - executor configurations, users, projects
and profiles must be configured here. Also the usage of <<section-systemtests-local-defaults,local defaults>>   is not possible - except those parts are defined on remote site with such names!  

==== Examples

===== Testing with already running integration test servers
[source,json]
----
include::../../gen/examples/gen_example_systemtest_using_local_integrationtestservers.json[]
----


=== Execution

==== With PDS tools
As a first step, download the latest release of `pds-tools` from https://github.com/mercedes-benz/sechub/releases.

Execute: 
`java -jar pds-tools.jar --systemTest=${pathToJson}`

==== JUnit tests
Just execute the Junit test from your IDE. 

=== Behavior

==== Stages
We have different stages:

- Setup
- Test 
- Shutdown

Every stage can contain different steps inside.
For example: The setup phase contains start scripts from SecHub and/or PDS solutions. 

Before a stage can be left and another is started, a check is done, if there is a need to wait for any processes
to be finished. When a script of the stage times out in mean time, the framework will stop with a failure message.

If not explicit defined, the test framework automatically uses dedicated defaults for script steps
inside the stage, but it is possible to alter this inside the configuration. Here an example:

[source,json]
----
{
  "script" : {
    "path" : "./01-start-single-docker-compose.sh",
    "process" : {
        "timeOut" : { <1>
           "amount" : 2,  <2>
           "unit" : "minutes", <3>
        }
        "stageWaits" : true <4>
    }
  }   
}
----
<1> Defines the timeout before the process will be forcibly terminated. The default is 5 Minutes
    When a timeout happens, the system test will fail!
<2> Accepted amount of time before timeout happens
<3> Time unit, can be `milliseconds`, `seconds`, `minutes`, `hours` 
<4> When `stageWaits` is `true` the stage will wait for the process to be done. The default is `false`. +
+
[NOTE]
====
The test preparation stage will automatically wait for defined PDS solutions and SecHub server to 
be up and running - means: 

You only need to setup `stageWaits` to `true` if you have written a special 
script which must be done (and does automatically end) before a stage shall be left. 

In this case the stage will wait until the script has finished or times out.

====

[TIP]
====
You do not need to define `stageWait` in test preparation steps: For those steps the framework
will always wait before the test is executed.
====

==== Auto configuration
===== Remote run
At a remote run, the configuration of the remote exissting {sechub} and {pds} environments
will not be changed!

[IMPORTANT]
====
There is no auto configuration phase on a remote run. All elements (profiles, executors, project,
etc. must all be configured before the test is run.
====

 

===== Local run

====== Projects
The defined projects will be created automatically. If a project exists with the defined name (e.g.
when a system test is restarted locally) the existing projected will be deleted!

====== Executor configurations
Every system test start will just create new executor configurations.

====== Profiles
The defined profiles inside test configuration model will be created and connected with the created
executor configurations. IF a profile does already exist with the defined project id, the existing 
one will be deleted.


