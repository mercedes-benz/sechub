// SPDX-License-Identifier: MIT
[[section-systemtests]]

== System tests
This chapter describes the system test framework.

[TIP]
====
The system test framework is designed, to make things easier for developers
when testing SecHub / PDS. It provides as many defaults as possible.
So it is normally not necessary to define much to have a running system test!

Do not try to configure every possible part, but instead try to define only 
necessary things and let the framework do the rest.
====

=== Write a test
This chapter describes the different parts inside the test configuration model.

System tests can be written in two ways:

2. Write a Junit test and use methods provided by `SystemTestAPI`
1. Writing a JSON file and execute it with `pds-tools`.

It does not matter if you write the configuration directly in JSON or with the java test API - 
the underlying model is the same. 


==== Variables

===== Environment variables
You can use environment variables inside the test configuration.
The prefix for those variables is `env`. 

For example, when you want to use the environment variable `USER_NAME` inside the 
configuration you reference it by `${env.USER_NAME}`.

[WARNING]
====
It is forbidden to use environment variables which have `${env.*` as content!
====

===== Secret environment variables
When an error appears, the altered configuration model will be logged as JSON to make it
easier to understand the problem. 

But inside this output, all standard variables (environment, runtime, user variables) are 
revealed and will be shown in plain text.

If you have any secret information which shall not be revealed inside log output this is no option
from a security perspective.

To hide such sensitive information you can use secret environment variables.

[WARNING]
====
It is forbidden to use secret environment variables which have `${env.*` or `${secretEnv.*` as content!
====
The prefix for those variables is `secretEnv`. 

For example, when you want to use the environment variable `USER_PASSWORD` inside the 
configuration you reference it by `${secretEnv.USER_PASSWORD}`.

[IMPORTANT]
====
When you are using secret environment variables but they are not defined at runtime,
the system test framework will fail with an error about the missing variables.
====


But those variables can only be used at some locations:

====== Inside script environments 
[source,json]
----
"script" : {
            "envVariables" : {
              "D_RESOLVED_SECRET" : "${secretEnv.USER_PASSWORD}" //<1>
            },
            "path" : "./05-start-single-sechub-network-docker-compose.sh",
            "arguments" : [ "will-not-be-revealed-as-argument:${secretEnv.USER_PASSWORD}" ] //<2>
          }
----
<1> This works, at runtime the environment entry for the script will contain `USER_PASSWORD` inside 
    variable `D_RESOLVED_SECRET`.
<2> The secret will not be sent as an argument (for security reasons we only allowe env entries)

====== Inside credentials
// FIXME 2023-04-05, albert: not implemented
TBD: Not implemented at the moment

===== User variables
You can define your own variables inside the test configuration.
The prefix for those variables is `variables`. 

For example, if you have defined the variable `uploadFolder` inside the 
configuration you can reference it by `${variables.uploadFolder}`.

===== Runtime variables
Some variables are created by the test framework and are available at runtime.
You can use such variables inside the test configuration with the prefix `runtime`. 

====== Workspace root
On startup a temporary workspace folder will be created and can be used inside the configuration.
The variable can be referenced with `${runtime.workspaceRoot}`.

*An example:*

- write a bash script which downloads some test source code from a git repository.
- the bash script uses `$1` to determine the target folder
- inside our test configuration we set the first argument of a test prepare script to 
  `${runtime.workspaceRoot}/sources1`.
- inside the test itself we reference it again with `${runtime.workspaceRoot}/sources1`
  as working directory for the client upload.

==== Setup
Inside the setup we define things necessary to setup our system test environment.

It is possible to run system tests on local side and just automatically start SecHub, 
PDS solutions and configure all automatically.

But it is also possible to use an existing real {sechub} platform and run the defined
tests there. The configuration is not tampered here - executor configurations, users, projects
and profiles must be configured here. Also the usage of <<section-systemtests-local-defaults,local defaults>>   is not possible - except those parts are defined on remote site with such names!  


===== Local

====== Defaults
[[section-systemtests-local-defaults]]
Following parts will be automatically defined when not inside configuration explicit defined

include::../../gen/gen_systemtests_default_fallbacks_table.adoc[]

===== Remote
It is also possible to use an existing real {sechub} platform and run the defined
tests there. The configuration is not tampered here - executor configurations, users, projects
and profiles must be configured here. Also the usage of <<section-systemtests-local-defaults,local defaults>>   is not possible - except those parts are defined on remote site with such names!  

==== Example
// FIXME 2023-04-05, albert: not implemented
TBD: Not implemented at the moment

=== Execution

==== With PDS tools
As a first step, download the latest release of `pds-tools` from https://github.com/mercedes-benz/sechub/releases.

Execute: 
`java -jar pds-tools.jar --systemTest=${pathToJson}`

==== JUnit tests
Just execute the Junit test from your IDE. 

=== Behavior

==== Stages
We have different stages:

- Setup
- Test preparation
- Shutdown

Every stage can contain different steps inside.
For example: The setup phase contains start scripts from SecHub and/or PDS solutions. 

Before a stage can be left and another is started, a check is done, if there is a need to wait for any processes
to be finished. When a script of the stage times out in mean time, the framework will stop with a failure message.

If not explicit defined, the test framework automatically uses dedicated defaults for script steps
inside the stage, but it is possible to alter this inside the configuration. Here an example:

[source,json]
----
{
  "script" : {
    "path" : "./01-start-single-docker-compose.sh",
    "process" : {
        "timeOut" : { <1>
           "amount" : 2,  <2>
           "unit" : "minutes", <3>
        }
        "stageWaits" : true <4>
    }
  }   
}
----
<1> Defines the timeout before the process will be forcibly terminated. The default is 5 Minutes
    When a timeout happens, the system test will fail!
<2> Accepted amount of time before timeout happens
<3> Time unit, can be `milliseconds`, `seconds`, `minutes`, `hours` 
<4> When `stageWaits` is `true` the stage will wait for the process to be done. The default is `false`. +
+
[NOTE]
====
The test preparation stage will automatically wait for defined PDS solutions and SecHub server to 
be up and running - means: 

You only need to setup `stageWaits` to `true` if you have written a special 
script which must be done (and does automatically end) before a stage shall be left. 

In this case the stage will wait until the script has finished or times out.
====



