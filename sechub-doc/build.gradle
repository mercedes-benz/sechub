// SPDX-License-Identifier: MIT

apply plugin: 'com.epages.restdocs-api-spec' //see https://github.com/ePages-de/restdocs-api-spec
apply plugin: 'org.asciidoctor.jvm.convert'
apply plugin: 'org.asciidoctor.jvm.pdf'

apply from: "openapi-workaround.gradle"

dependencies {
    def wanted = []
    def unwanted = [
        'sechub-cli', /* go only, no library dependency here*/
        'sechub-doc',/* itself ... */
        'sechub-developertools',/* only tests or tools */
        'sechub-other',/* not java */
        'sechub-pds-solutions', /* only pds scripts*/
        'sechub-pds-tools', /* only pds tooling + avoid cycles */
        'sechub-api-java', /* the api project needs sechub-doc tests (and compile) for open api json files. So we may not have this as relation! */
        'sechub-systemtest', /* avoid cyclic dependency, see AdoptedSystemTestDefaultFallbacks javadoc for more information */
        'sechub-wrapper-owasp-zap',

        ]
    /* fetch all sub projects, except unwanted and all only used for testing */
    for (Project inspectedProject: rootProject.allprojects){
        if (rootProject.equals(inspectedProject)){
            // root project is always not wanted
            continue
        }
        def projectName = inspectedProject.name
        if (projectName.endsWith('test') ){
            // test projects are always not wanted, except systemtest (we generate doc here as well)
            continue
        }
        if (projectName.startsWith('deprecated')){
            // we do not document deprecated parts
            continue
        }
        if (projectName.startsWith('example')){
            // we do not document example parts
            continue
        }
        if (projectName.endsWith('testframework')){
            // testframework projects are always not wanted
            continue
        }
        if (unwanted.contains(projectName)){
            // special unwanted - so inore
            continue
        }
        wanted << projectName
        //println ">>$projectName"
    }
    /* all projects are added as implementation, so can be inspected by Reflections */
    for (String wantedProjectName: wanted){
        implementation project(":${wantedProjectName}")
    }
    implementation library.apache_commons_io

    implementation spring_boot_dependency.jackson_core
    implementation spring_boot_dependency.jackson_databind
    implementation "com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:${spring_boot_dependency_version.jackson_databind}"
    
    testImplementation library.epages_restdoc_api_spec_mockmvc
    testImplementation project(':sechub-commons-model-testframework')

    /* next parts are necessary for rest doc generation in conjunction
       with reflection annoation scanning done wiht @UsecaseRestDoc
       the tests with restdoc are settled inside sechub-doc to have
       abbility to get inside gradle access to tests (each gradle project
       has normally only access to its own test classes... )*/
    testImplementation  project(':sechub-testframework')
    testImplementation (library.springframework_restdocs)
    testImplementation (library.springframework_security_test)
}

def targetAsciiDocGenFolder="${project.projectDir}/src/docs/asciidoc/documents/gen"
def asciidocBuildDir="$buildDir/docs/asciidoc";
def imagesBuildDir="$buildDir/docs/asciidoc/images";
def finalHTMLDir = "$buildDir/docs/final-html"

def clientVersion = versionData.getClientDocsVersion()
def pdsVersion = versionData.getPdsDocsVersion()
def serverVersion = versionData.getServerDocsVersion()

task dropOldGeneratedAsciidoc(dependsOn: 'test'){
    doFirst {
        //cleanup former old data
        delete fileTree (
            dir: "${targetAsciiDocGenFolder}",
            // *-version.adoc files are generated iniital by each gradle call and may not be deleted
            exclude: ['README.md','.gitignore','*-version.adoc'])
    }
}

task generateAsciidoc(type: JavaExec, dependsOn: 'dropOldGeneratedAsciidoc') {


    mainClass = 'com.mercedesbenz.sechub.docgen.AsciidocGenerator'
    args = ["${targetAsciiDocGenFolder}"]
    group = 'sechub'
    description = 'Starts asciidoc generator. Will generate planuml files and more'
    classpath = sourceSets.test.runtimeClasspath

}

asciidoctor.doFirst {
    // pre-process
    copy {
        /* Why do we do this here ? Because PDF converter does read the images
         * before the standard copy part from the gradle plugin for asciidoctor is done
         * so generated images - e.g. plantuml are not available at pdf render time
         * so this is ugly but necessary. We use target images folder because the images
         * dir is referenced by the html5 output directly - so it works at html5 and pdf
         * (unfortunately html has absolute pathes... so after asciidoc generation we need a fix
         * on location where html output must use relative pathes - e.g. website project ...)
         */

        from file('src/docs/asciidoc/images')
        into file("${imagesBuildDir}")
        include '*.*'
        include 'gen/**'
    }

    }

asciidoctor {

    outputOptions {
        backends "html5", "pdf"

        separateOutputDirs = false
    }

    baseDir 'src/docs/asciidoc'

    attributes 'build-gradle': file('build.gradle'),
            'source-highlighter': 'coderay',
            'toc': 'left',
            'toclevels': '5',
            'icons': 'font',
            'setanchors': 'true',
            'idprefix': '',
            'idseparator': '-',
            'docinfo1': 'true',
            'sectnums': 'true',
            'sectnumlevels': '5',
            'version': rootProject.version


    /* has to be defined inside this build script again, because
       asciidoctor pdf seems to have an problem with relational path
       definitions...*/

    attributes \
        'sourcedir': file('src/docs'),
        'imagesdir': "${imagesBuildDir}"

    sources {
        include 'sechub-techdoc.adoc',
        'sechub-architecture.adoc',
        'sechub-client.adoc',
        'sechub-operations.adoc',
        'sechub-restapi.adoc',
        'sechub-developer-quickstart-guide.adoc',
        'sechub-product-delegation-server.adoc',
        'sechub-getting-started.adoc',
        'sechub-tutorials.adoc'
    }

    // workaround to enable missing includes checking. See https://github.com/asciidoctor/asciidoctor-gradle-plugin/issues/154
    ext.capturedOutput = [ ]
    def listener = { ext.capturedOutput << it } as StandardOutputListener

    logging.addStandardErrorListener(listener)
    logging.addStandardOutputListener(listener)

    doLast {
        logging.removeStandardOutputListener(listener)
        logging.removeStandardErrorListener(listener)
        ext.capturedOutput.join('').with { output ->
            if (output =~ /include file not found:/) {
                throw new RuntimeException("Include file(s) not found, see next lines for details:\n" + output)
            }
        }
    }


}

asciidoctorj {

    version = "${libraryVersion.asciidoctor_j}"

    // Enable jdiagram support (new way)
    // see https://asciidoctor.github.io/asciidoctor-gradle-plugin/development-3.x/user-guide/#diagram
    modules {
       diagram.use()
       diagram.version "${libraryVersion.asciidoctor_j_diagram}"
    }
}

task convertSecHubHTMLPages(type: Copy){
    dependsOn asciidoctor

     /* Why those replace pattern stuff ?
      * ----------------------------------
      * Because of PDF problems with rendered images, we were forced to use absolute image pathes so
      * PDF documented has got content inside (see build.gradle in sechub-doc for info)
      *
      * But here we do NOT want absolute pathes... we want a normal website with relative ones.
      * I really tried to fix this by configuring asciidoctor plugin, but failed... either it worked for pdf or for html
      * but not for both. No matter if using newest gradle plugin, newer asciidoc-pdf etc. etc.
      *
      * So this is a workaround - we render with absolute pathes. so getting correct pdf. For html files used here on website
      * the absolute pathes are converted back to relative ones. Simplest way to provide this.
      */
     def originAbsPath = "${asciidocBuildDir}"
     def replacePattern = originAbsPath.replaceAll("\\\\", "/")
     if (! replacePattern.endsWith("/")){
        replacePattern+="/"
     }

     /* fix html only */
     from("${originAbsPath}") {
         include '**/*.html'
         // remove absolute path...
         filter { line -> line.replaceAll("${replacePattern}", '') }
     }
     into "${finalHTMLDir}"

     includeEmptyDirs = false
}

task copyImagesToFinalDir(type: Copy) {
    dependsOn asciidoctor

    from "${imagesBuildDir}"
    into "${finalHTMLDir}/images"
}

task prepareFinalHTML {
    dependsOn 'convertSecHubHTMLPages'
    dependsOn 'copyImagesToFinalDir'
}

/* collector task for all documentation parts - but does NOT build anything, so suitable for build chain - for a documentation build from scratch
   there exists another task: buildDoc which does all in one call*/
task documentation(){
     group 'sechub'
     description 'This will generate asciidoctor documentation - but preconditions must be fulfilled (e.g. build, integrationtest, certificates)'

     dependsOn 'generateAsciidoc'
     dependsOn 'asciidoctor'
     dependsOn 'prepareFinalHTML'

     // see https://stackoverflow.com/questions/32907275/gradle-custom-task-which-runs-multiple-tasks
     tasks.findByName('asciidoctor').mustRunAfter 'generateAsciidoc'
     tasks.findByName('prepareFinalHTML').mustRunAfter 'asciidoctor'
}

task buildDoc(type: Exec){
    group 'sechub'
    description 'This will build full documentation from scratch - will build, test ensure all dependencies are fulfilled before'

    workingDir = "${rootProject.projectDir}"

    commandLine = "./buildDoc"
}

task createDownloadLinks(type: Exec) {
    group 'sechub'
    description 'This creates the HTML code for direct download'
    dependsOn 'documentation'

    workingDir = "."
    commandLine 'sh', '-c', "helperscripts/create-download-html.sh client ${clientVersion} > ${finalHTMLDir}/client-download.html ; helperscripts/create-download-html.sh pds ${pdsVersion} > ${finalHTMLDir}/pds-download.html ; helperscripts/create-download-html.sh server ${serverVersion} > ${finalHTMLDir}/server-download.html"
}

task "documentation-with-pages" {
    group 'sechub'
    description 'This will create documentation and setup sechub pages under /docs '

    dependsOn 'documentation'
    dependsOn 'createDownloadLinks'
}

openapi3 {
    server = 'https://localhost'
    title = 'SecHub API'
    description = 'SecHub API description'
    tagDescriptionsPropertiesFile = 'src/test/resources/openapi/tags.yaml'
    version = "${versionData.getServerVersion()}" // Set the OpenAPI version to the SecHub server version
    format = 'json'
}
