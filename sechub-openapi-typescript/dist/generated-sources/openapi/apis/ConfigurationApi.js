"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * SecHub API
 * The SecHub API is a collection of RESTful endpoints. It is designed to be used by users and administrators of the SecHub application.  Most of the endpoints are protected by basic authentication.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationApi = void 0;
const runtime = require("../runtime");
const index_1 = require("../models/index");
/**
 *
 */
class ConfigurationApi extends runtime.BaseAPI {
    /**
     * An administrator assigns an execution profile to an existing project
     * Admin assigns execution profile to project
     */
    async adminAssignExecutionProfileToProjectRaw(requestParameters, initOverrides) {
        if (requestParameters['profileId'] == null) {
            throw new runtime.RequiredError('profileId', 'Required parameter "profileId" was null or undefined when calling adminAssignExecutionProfileToProject().');
        }
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError('projectId', 'Required parameter "projectId" was null or undefined when calling adminAssignExecutionProfileToProject().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/execution/profile/{profileId}/project/{projectId}`;
        urlPath = urlPath.replace(`{${"profileId"}}`, encodeURIComponent(String(requestParameters['profileId'])));
        urlPath = urlPath.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId'])));
        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator assigns an execution profile to an existing project
     * Admin assigns execution profile to project
     */
    async adminAssignExecutionProfileToProject(requestParameters, initOverrides) {
        await this.adminAssignExecutionProfileToProjectRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator creates an execution profile
     * Admin creates an execution profile
     */
    async adminCreateExecutionProfileRaw(requestParameters, initOverrides) {
        if (requestParameters['profileId'] == null) {
            throw new runtime.RequiredError('profileId', 'Required parameter "profileId" was null or undefined when calling adminCreateExecutionProfile().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/execution/profile/{profileId}`;
        urlPath = urlPath.replace(`{${"profileId"}}`, encodeURIComponent(String(requestParameters['profileId'])));
        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.ProductExecutionProfileToJSON)(requestParameters['productExecutionProfile']),
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator creates an execution profile
     * Admin creates an execution profile
     */
    async adminCreateExecutionProfile(requestParameters, initOverrides) {
        await this.adminCreateExecutionProfileRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator creates an executor a new configuration entry.
     * Admin creates an executor configuration
     */
    async adminCreateExecutorConfigurationRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/executor`;
        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.ProductExecutorConfigToJSON)(requestParameters['productExecutorConfig']),
        }, initOverrides);
        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse(response);
        }
        else {
            return new runtime.TextApiResponse(response);
        }
    }
    /**
     * An administrator creates an executor a new configuration entry.
     * Admin creates an executor configuration
     */
    async adminCreateExecutorConfiguration(requestParameters = {}, initOverrides) {
        const response = await this.adminCreateExecutorConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * An administrator wants to create a new template or to update a template definition
     * Admin creates or updates a template
     */
    async adminCreateOrUpdateTemplateRaw(requestParameters, initOverrides) {
        if (requestParameters['templateId'] == null) {
            throw new runtime.RequiredError('templateId', 'Required parameter "templateId" was null or undefined when calling adminCreateOrUpdateTemplate().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/template/{templateId}`;
        urlPath = urlPath.replace(`{${"templateId"}}`, encodeURIComponent(String(requestParameters['templateId'])));
        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator wants to create a new template or to update a template definition
     * Admin creates or updates a template
     */
    async adminCreateOrUpdateTemplate(requestParameters, initOverrides) {
        await this.adminCreateOrUpdateTemplateRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator deletes execution profile
     * Admin deletes execution profile
     */
    async adminDeleteExecutionProfileRaw(requestParameters, initOverrides) {
        if (requestParameters['profileId'] == null) {
            throw new runtime.RequiredError('profileId', 'Required parameter "profileId" was null or undefined when calling adminDeleteExecutionProfile().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/execution/profile/{profileId}`;
        urlPath = urlPath.replace(`{${"profileId"}}`, encodeURIComponent(String(requestParameters['profileId'])));
        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator deletes execution profile
     * Admin deletes execution profile
     */
    async adminDeleteExecutionProfile(requestParameters, initOverrides) {
        await this.adminDeleteExecutionProfileRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator deletes an executor by removing the configuration entry identified by its uuid
     * Admin deletes executor configuration
     */
    async adminDeleteExecutorConfigurationRaw(requestParameters, initOverrides) {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError('uuid', 'Required parameter "uuid" was null or undefined when calling adminDeleteExecutorConfiguration().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/executor/{uuid}`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));
        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator deletes an executor by removing the configuration entry identified by its uuid
     * Admin deletes executor configuration
     */
    async adminDeleteExecutorConfiguration(requestParameters, initOverrides) {
        await this.adminDeleteExecutorConfigurationRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator wants to delete an existing template
     * Admin deletes a template
     */
    async adminDeleteTemplateRaw(requestParameters, initOverrides) {
        if (requestParameters['templateId'] == null) {
            throw new runtime.RequiredError('templateId', 'Required parameter "templateId" was null or undefined when calling adminDeleteTemplate().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/template/{templateId}`;
        urlPath = urlPath.replace(`{${"templateId"}}`, encodeURIComponent(String(requestParameters['templateId'])));
        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator wants to delete an existing template
     * Admin deletes a template
     */
    async adminDeleteTemplate(requestParameters, initOverrides) {
        await this.adminDeleteTemplateRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator deletes an asset completely.
     * Admin deletes asset comletely
     */
    async adminDeletesAssetCompletelyRaw(requestParameters, initOverrides) {
        if (requestParameters['assetId'] == null) {
            throw new runtime.RequiredError('assetId', 'Required parameter "assetId" was null or undefined when calling adminDeletesAssetCompletely().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/asset/{assetId}`;
        urlPath = urlPath.replace(`{${"assetId"}}`, encodeURIComponent(String(requestParameters['assetId'])));
        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator deletes an asset completely.
     * Admin deletes asset comletely
     */
    async adminDeletesAssetCompletely(requestParameters, initOverrides) {
        await this.adminDeletesAssetCompletelyRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator deletes a file fom an asset.
     * Admin deletes an asset file
     */
    async adminDeletesAssetFileRaw(requestParameters, initOverrides) {
        if (requestParameters['assetId'] == null) {
            throw new runtime.RequiredError('assetId', 'Required parameter "assetId" was null or undefined when calling adminDeletesAssetFile().');
        }
        if (requestParameters['fileName'] == null) {
            throw new runtime.RequiredError('fileName', 'Required parameter "fileName" was null or undefined when calling adminDeletesAssetFile().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/asset/{assetId}/file/{fileName}`;
        urlPath = urlPath.replace(`{${"assetId"}}`, encodeURIComponent(String(requestParameters['assetId'])));
        urlPath = urlPath.replace(`{${"fileName"}}`, encodeURIComponent(String(requestParameters['fileName'])));
        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator deletes a file fom an asset.
     * Admin deletes an asset file
     */
    async adminDeletesAssetFile(requestParameters, initOverrides) {
        await this.adminDeletesAssetFileRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator downloads a file fom an asset.
     * Admin downloads an asset file
     */
    async adminDownloadsAssetFileRaw(requestParameters, initOverrides) {
        if (requestParameters['assetId'] == null) {
            throw new runtime.RequiredError('assetId', 'Required parameter "assetId" was null or undefined when calling adminDownloadsAssetFile().');
        }
        if (requestParameters['fileName'] == null) {
            throw new runtime.RequiredError('fileName', 'Required parameter "fileName" was null or undefined when calling adminDownloadsAssetFile().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/asset/{assetId}/file/{fileName}`;
        urlPath = urlPath.replace(`{${"assetId"}}`, encodeURIComponent(String(requestParameters['assetId'])));
        urlPath = urlPath.replace(`{${"fileName"}}`, encodeURIComponent(String(requestParameters['fileName'])));
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.BlobApiResponse(response);
    }
    /**
     * An administrator downloads a file fom an asset.
     * Admin downloads an asset file
     */
    async adminDownloadsAssetFile(requestParameters, initOverrides) {
        const response = await this.adminDownloadsAssetFileRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * An administrator wants to inspect the runtime status of template setup. The health check trigger will return
     * Admin executes a template health check and fetches result
     */
    async adminExecuteTemplatesHealthCheckRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/templates/healthcheck`;
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.TemplatesHealthCheckResultFromJSON)(jsonValue));
    }
    /**
     * An administrator wants to inspect the runtime status of template setup. The health check trigger will return
     * Admin executes a template health check and fetches result
     */
    async adminExecuteTemplatesHealthCheck(initOverrides) {
        const response = await this.adminExecuteTemplatesHealthCheckRaw(initOverrides);
        return await response.value();
    }
    /**
     * An administrator fetches details about an asset. For example: the result will contain names but also checksum of files.
     * Admin fetches asset details
     */
    async adminFetchAssetDetailsRaw(requestParameters, initOverrides) {
        if (requestParameters['assetId'] == null) {
            throw new runtime.RequiredError('assetId', 'Required parameter "assetId" was null or undefined when calling adminFetchAssetDetails().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/asset/{assetId}/details`;
        urlPath = urlPath.replace(`{${"assetId"}}`, encodeURIComponent(String(requestParameters['assetId'])));
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.AssetDetailDataFromJSON)(jsonValue));
    }
    /**
     * An administrator fetches details about an asset. For example: the result will contain names but also checksum of files.
     * Admin fetches asset details
     */
    async adminFetchAssetDetails(requestParameters, initOverrides) {
        const response = await this.adminFetchAssetDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * An administrator fetches all available asset ids.
     * Admin fetches asset ids
     */
    async adminFetchAssetIdsRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/asset/ids`;
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * An administrator fetches all available asset ids.
     * Admin fetches asset ids
     */
    async adminFetchAssetIds(initOverrides) {
        const response = await this.adminFetchAssetIdsRaw(initOverrides);
        return await response.value();
    }
    /**
     * An administrator fetches current auto-cleanup configuration
     * Admin fetches auto cleanup configuration
     */
    async adminFetchAutoCleanupConfigurationRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/autoclean`;
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.AdministrationAutoCleanupConfigFromJSON)(jsonValue));
    }
    /**
     * An administrator fetches current auto-cleanup configuration
     * Admin fetches auto cleanup configuration
     */
    async adminFetchAutoCleanupConfiguration(initOverrides) {
        const response = await this.adminFetchAutoCleanupConfigurationRaw(initOverrides);
        return await response.value();
    }
    /**
     * An administrator fetches details about an execution profile
     * Admin fetches execution profile
     */
    async adminFetchExecutionProfileRaw(requestParameters, initOverrides) {
        if (requestParameters['profileId'] == null) {
            throw new runtime.RequiredError('profileId', 'Required parameter "profileId" was null or undefined when calling adminFetchExecutionProfile().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/execution/profile/{profileId}`;
        urlPath = urlPath.replace(`{${"profileId"}}`, encodeURIComponent(String(requestParameters['profileId'])));
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.ProductExecutionProfileFromJSON)(jsonValue));
    }
    /**
     * An administrator fetches details about an execution profile
     * Admin fetches execution profile
     */
    async adminFetchExecutionProfile(requestParameters, initOverrides) {
        const response = await this.adminFetchExecutionProfileRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * An administrator fetches execution profile list
     * Admin fetches execution profile list
     */
    async adminFetchExecutionProfileListRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/execution/profiles`;
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.ProductExecutionProfilesListFromJSON)(jsonValue));
    }
    /**
     * An administrator fetches execution profile list
     * Admin fetches execution profile list
     */
    async adminFetchExecutionProfileList(initOverrides) {
        const response = await this.adminFetchExecutionProfileListRaw(initOverrides);
        return await response.value();
    }
    /**
     * An administrator fetches one explicit executor configuration by its uuid.
     * Admin fetches executor configuration
     */
    async adminFetchExecutorConfigurationRaw(requestParameters, initOverrides) {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError('uuid', 'Required parameter "uuid" was null or undefined when calling adminFetchExecutorConfiguration().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/executor/{uuid}`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.ProductExecutorConfigFromJSON)(jsonValue));
    }
    /**
     * An administrator fetches one explicit executor configuration by its uuid.
     * Admin fetches executor configuration
     */
    async adminFetchExecutorConfiguration(requestParameters, initOverrides) {
        const response = await this.adminFetchExecutorConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * An administrator fetches executor configuration list which contains all executor configurations
     * Admin fetches executor configuration list
     */
    async adminFetchExecutorConfigurationListRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/executors`;
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.ProductExecutorConfigListFromJSON)(jsonValue));
    }
    /**
     * An administrator fetches executor configuration list which contains all executor configurations
     * Admin fetches executor configuration list
     */
    async adminFetchExecutorConfigurationList(initOverrides) {
        const response = await this.adminFetchExecutorConfigurationListRaw(initOverrides);
        return await response.value();
    }
    /**
     * An administrator fetches mapping configuration by its ID.
     * Admin fetches mapping configuration
     */
    async adminFetchMappingConfigurationRaw(requestParameters, initOverrides) {
        if (requestParameters['mappingId'] == null) {
            throw new runtime.RequiredError('mappingId', 'Required parameter "mappingId" was null or undefined when calling adminFetchMappingConfiguration().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/mapping/{mappingId}`;
        urlPath = urlPath.replace(`{${"mappingId"}}`, encodeURIComponent(String(requestParameters['mappingId'])));
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.MappingDataFromJSON)(jsonValue));
    }
    /**
     * An administrator fetches mapping configuration by its ID.
     * Admin fetches mapping configuration
     */
    async adminFetchMappingConfiguration(requestParameters, initOverrides) {
        const response = await this.adminFetchMappingConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * An administrator wants to fetch the template definition by template id
     * Admin fetches template
     */
    async adminFetchTemplateRaw(requestParameters, initOverrides) {
        if (requestParameters['templateId'] == null) {
            throw new runtime.RequiredError('templateId', 'Required parameter "templateId" was null or undefined when calling adminFetchTemplate().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/template/{templateId}`;
        urlPath = urlPath.replace(`{${"templateId"}}`, encodeURIComponent(String(requestParameters['templateId'])));
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.TemplateDefinitionFromJSON)(jsonValue));
    }
    /**
     * An administrator wants to fetch the template definition by template id
     * Admin fetches template
     */
    async adminFetchTemplate(requestParameters, initOverrides) {
        const response = await this.adminFetchTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * An administrator wants to fetch a list containing all available template identifiers
     * Admin fetches template ids
     */
    async adminFetchTemplateIdsRaw(requestParameters, initOverrides) {
        if (requestParameters['templateId'] == null) {
            throw new runtime.RequiredError('templateId', 'Required parameter "templateId" was null or undefined when calling adminFetchTemplateIds().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/templates`;
        urlPath = urlPath.replace(`{${"templateId"}}`, encodeURIComponent(String(requestParameters['templateId'])));
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * An administrator wants to fetch a list containing all available template identifiers
     * Admin fetches template ids
     */
    async adminFetchTemplateIds(requestParameters, initOverrides) {
        const response = await this.adminFetchTemplateIdsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * An administrator unassigns an execution profile from a projects.
     * Admin unassigns execution profile from project
     */
    async adminUnassignExecutionProfileFromProjectRaw(requestParameters, initOverrides) {
        if (requestParameters['profileId'] == null) {
            throw new runtime.RequiredError('profileId', 'Required parameter "profileId" was null or undefined when calling adminUnassignExecutionProfileFromProject().');
        }
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError('projectId', 'Required parameter "projectId" was null or undefined when calling adminUnassignExecutionProfileFromProject().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/execution/profile/{profileId}/project/{projectId}`;
        urlPath = urlPath.replace(`{${"profileId"}}`, encodeURIComponent(String(requestParameters['profileId'])));
        urlPath = urlPath.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId'])));
        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator unassigns an execution profile from a projects.
     * Admin unassigns execution profile from project
     */
    async adminUnassignExecutionProfileFromProject(requestParameters, initOverrides) {
        await this.adminUnassignExecutionProfileFromProjectRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator changes auto-cleanup configuration
     * Admin updates auto cleanup configuration
     */
    async adminUpdateAutoCleanupConfigurationRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/autoclean`;
        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.AdministrationAutoCleanupConfigToJSON)(requestParameters['administrationAutoCleanupConfig']),
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator changes auto-cleanup configuration
     * Admin updates auto cleanup configuration
     */
    async adminUpdateAutoCleanupConfiguration(requestParameters = {}, initOverrides) {
        await this.adminUpdateAutoCleanupConfigurationRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator updates dedicated execution profile
     * Admin updates execution profile
     */
    async adminUpdateExecutionProfileRaw(requestParameters, initOverrides) {
        if (requestParameters['profileId'] == null) {
            throw new runtime.RequiredError('profileId', 'Required parameter "profileId" was null or undefined when calling adminUpdateExecutionProfile().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/execution/profile/{profileId}`;
        urlPath = urlPath.replace(`{${"profileId"}}`, encodeURIComponent(String(requestParameters['profileId'])));
        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.ProductExecutionProfileToJSON)(requestParameters['productExecutionProfile']),
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator updates dedicated execution profile
     * Admin updates execution profile
     */
    async adminUpdateExecutionProfile(requestParameters, initOverrides) {
        await this.adminUpdateExecutionProfileRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator updates dedicated executor configuration. The update does change description, enabled state and also used executors, but Will NOT change any associations between profile and projects.
     * Admin updates executor configuration setup
     */
    async adminUpdateExecutorConfigRaw(requestParameters, initOverrides) {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError('uuid', 'Required parameter "uuid" was null or undefined when calling adminUpdateExecutorConfig().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/executor/{uuid}`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));
        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.ProductExecutorConfigToJSON)(requestParameters['productExecutorConfig']),
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator updates dedicated executor configuration. The update does change description, enabled state and also used executors, but Will NOT change any associations between profile and projects.
     * Admin updates executor configuration setup
     */
    async adminUpdateExecutorConfig(requestParameters, initOverrides) {
        await this.adminUpdateExecutorConfigRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator changes mapping configuration. Mappings represents a generic mechanism to replace a given string, matched by configured regular expression pattern with a replacement string. Some of the mappings are used for adapter behaviour.
     * Admin updates mapping configuration
     */
    async adminUpdateMappingConfigurationRaw(requestParameters, initOverrides) {
        if (requestParameters['mappingId'] == null) {
            throw new runtime.RequiredError('mappingId', 'Required parameter "mappingId" was null or undefined when calling adminUpdateMappingConfiguration().');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/config/mapping/{mappingId}`;
        urlPath = urlPath.replace(`{${"mappingId"}}`, encodeURIComponent(String(requestParameters['mappingId'])));
        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.MappingDataToJSON)(requestParameters['mappingData']),
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator changes mapping configuration. Mappings represents a generic mechanism to replace a given string, matched by configured regular expression pattern with a replacement string. Some of the mappings are used for adapter behaviour.
     * Admin updates mapping configuration
     */
    async adminUpdateMappingConfiguration(requestParameters, initOverrides) {
        await this.adminUpdateMappingConfigurationRaw(requestParameters, initOverrides);
    }
    /**
     * An administrator uploads a file for an asset. If the file already exits, it will be overriden.
     * Admin uploads an asset file
     */
    async adminUploadsAssetFileRaw(requestParameters, initOverrides) {
        if (requestParameters['assetId'] == null) {
            throw new runtime.RequiredError('assetId', 'Required parameter "assetId" was null or undefined when calling adminUploadsAssetFile().');
        }
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError('file', 'Required parameter "file" was null or undefined when calling adminUploadsAssetFile().');
        }
        if (requestParameters['checkSum'] == null) {
            throw new runtime.RequiredError('checkSum', 'Required parameter "checkSum" was null or undefined when calling adminUploadsAssetFile().');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);
        let formParams;
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        }
        else {
            formParams = new URLSearchParams();
        }
        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file']);
        }
        if (requestParameters['checkSum'] != null) {
            formParams.append('checkSum', requestParameters['checkSum']);
        }
        let urlPath = `/api/admin/asset/{assetId}/file`;
        urlPath = urlPath.replace(`{${"assetId"}}`, encodeURIComponent(String(requestParameters['assetId'])));
        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator uploads a file for an asset. If the file already exits, it will be overriden.
     * Admin uploads an asset file
     */
    async adminUploadsAssetFile(requestParameters, initOverrides) {
        await this.adminUploadsAssetFileRaw(requestParameters, initOverrides);
    }
}
exports.ConfigurationApi = ConfigurationApi;
