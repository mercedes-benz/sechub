"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * SecHub API
 * The SecHub API is a collection of RESTful endpoints. It is designed to be used by users and administrators of the SecHub application.  Most of the endpoints are protected by basic authentication.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OtherApi = void 0;
const runtime = require("../runtime");
const index_1 = require("../models/index");
/**
 *
 */
class OtherApi extends runtime.BaseAPI {
    /**
     * An administrator disables scheduler job processing. This can be a preparation for system wide update - when scheduling is stoped, user can ask for new SecHub Jobs etc. But as long as scheduler is stopped nothing is executed - so JVMs/PODs can be updated in cluster
     * Admin disables job processing in scheduler
     */
    async adminDisableSchedulerJobProcessingRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/scheduler/disable/job-processing`;
        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator disables scheduler job processing. This can be a preparation for system wide update - when scheduling is stoped, user can ask for new SecHub Jobs etc. But as long as scheduler is stopped nothing is executed - so JVMs/PODs can be updated in cluster
     * Admin disables job processing in scheduler
     */
    async adminDisableSchedulerJobProcessing(initOverrides) {
        await this.adminDisableSchedulerJobProcessingRaw(initOverrides);
    }
    /**
     * An administrator starts scheduler job processing. This can be a necessary step after a system wide update where processing of jobs was stoped before.
     * Admin enables scheduler job processing
     */
    async adminEnableSchedulerJobProcessingRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/scheduler/enable/job-processing`;
        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator starts scheduler job processing. This can be a necessary step after a system wide update where processing of jobs was stoped before.
     * Admin enables scheduler job processing
     */
    async adminEnableSchedulerJobProcessing(initOverrides) {
        await this.adminEnableSchedulerJobProcessingRaw(initOverrides);
    }
    /**
     * An administrator fetches the current SecHub server runtime data. Only administrators are allowed to do this because it contains the server version and knowing the exact server version makes it easier for penetration tester or attacker to attack the system.
     * Admin fetches server runtime data
     */
    async adminFetchServerRuntimeDataRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/info/server`;
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.ServerRuntimeDataFromJSON)(jsonValue));
    }
    /**
     * An administrator fetches the current SecHub server runtime data. Only administrators are allowed to do this because it contains the server version and knowing the exact server version makes it easier for penetration tester or attacker to attack the system.
     * Admin fetches server runtime data
     */
    async adminFetchServerRuntimeData(initOverrides) {
        const response = await this.adminFetchServerRuntimeDataRaw(initOverrides);
        return await response.value();
    }
    /**
     * An administrator fetches current known status information about sechub
     * Admin lists status information
     */
    async adminListStatusInformationRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/status`;
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(index_1.StatusEntryFromJSON));
    }
    /**
     * An administrator fetches current known status information about sechub
     * Admin lists status information
     */
    async adminListStatusInformation(initOverrides) {
        const response = await this.adminListStatusInformationRaw(initOverrides);
        return await response.value();
    }
    /**
     * An administrator wants to update information about scheduler status
     * Admin trigger scheduler status refresh
     */
    async adminTriggerRefreshOfSchedulerStatusRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/admin/scheduler/status/refresh`;
        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * An administrator wants to update information about scheduler status
     * Admin trigger scheduler status refresh
     */
    async adminTriggerRefreshOfSchedulerStatus(initOverrides) {
        await this.adminTriggerRefreshOfSchedulerStatusRaw(initOverrides);
    }
    /**
     * User lists jobs for project
     * User lists jobs for project
     */
    async userListsJobsForProjectRaw(requestParameters, initOverrides) {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError('projectId', 'Required parameter "projectId" was null or undefined when calling userListsJobsForProject().');
        }
        const queryParameters = {};
        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }
        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }
        if (requestParameters['withMetaData'] != null) {
            queryParameters['withMetaData'] = requestParameters['withMetaData'];
        }
        if (requestParameters['allParams'] != null) {
            queryParameters['allParams'] = requestParameters['allParams'];
        }
        const headerParameters = {};
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        let urlPath = `/api/project/{projectId}/jobs`;
        urlPath = urlPath.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId'])));
        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.SecHubJobInfoForUserListPageFromJSON)(jsonValue));
    }
    /**
     * User lists jobs for project
     * User lists jobs for project
     */
    async userListsJobsForProject(requestParameters, initOverrides) {
        const response = await this.userListsJobsForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.OtherApi = OtherApi;
